# Virtual Machine Introspection: Techniques and Applications（ARES 2015）



VMI[^1]的概念由Garfinkel和Rosenblum于2003年首次提出，作为一种虚拟机监控程序级入侵检测系统（IDS），它结合了基于网络和基于主机的IDS的优点[^2]，即隔离和可见性[^3]。

## 1. 介绍

### 基于VMI的应用

优点：

* 抗篡改：高度解耦并与不受信任的虚拟机隔离，这些vm被认为无法访问或篡改hypervisor；
* 高效：能够检查任何OS活动，因为hypervisor(特权由VMI系统继承)有一个完造的试图，访问所有guest os的状态（CPU寄存器、内存和设备等）；
* 规避：由于hypervisor在guest os和底层硬件之间的插入，因此能够修改任何这些状态并干扰每个guest os的活动。

存在的不足：

* 语义鸿沟[^4]：hypervisor试图只能获取到无具体语义的字节流，没有操作系统的抽象语义（进程、文件、套接字等数据结构）；

## 2. 弥补语义鸿沟

根据检索语义的位置和具体方法分类：

a. in-VM

b. out-of-VM 交付: 显式（从os 源码、内核符号表、技术引用等提取），派生自底层硬件架构

c. out-of-VM 派生：trap handling，trap forcing

d. 混合方法：trap forcing，数据重定向/影子内存，进程移植，函数调用注入；

### a. in-VM

Challenge：安全性，in-VM agent与hypervisor之间的协调。agent负责将监控的活动暴露给hyperv，hyperv负责启动所需的安全策略。

Lares[^8]通过hypervisor注入感兴趣的内核组件（sys call dispatcher），每个hoo调用相应的handler，handler与hyperv的交互通过hypercall。hyperv通过写保护的内存页对hook和handler进行保护。

SIM framework[^9]与Lares非常类似，不同之处在于受hook的活动的信息通过一个安全的内存空间记录，而不是hypercal传给hyperv。hyperv或者安全的vm可以访问这个空间。

### b. out-of-VM 交付

关于来宾操作系统内部和感兴趣的操作系统数据结构的位置/定义的知识是:

i) 明确地包含在VMI系统中；

ii) 从操作系统源代码中提取；

iii) 通过可用的内核符号获得。

Livewire[^1]目的是检测在VMware工作站hypervisor[10]上运行的linux虚拟机中的**入侵**。Livewire使用一个适应于crash[11]的系统管理程序来检索关于linux操作系统数据结构的语义信息，这是一个集成了linux内核知识的linux内核转储分析工具。特别地，Livewire可以定期比较系统管理程序在崩溃时获得的OS状态信息，以及通过远程shell从OS本地工具(例如ps、ifconfig、netstat…)获得的信息。这两个**视图之间的不一致**可能揭示系统的入侵。

VMwatcher[^12]通过内核符号文件系统弥补了linux客户操作系统的语义差距。

Payne等人提出了XenAccess[^13]，一个Xen[^14]的VMI库，它创建了domU内存的高级语义感知抽象，以方便从dom0访问该内存。XenAccess使用从linux操作系统源代码中提取的知识或使用Windows[15]的技术参考来遍历不同的数据结构。Payne后来扩展了XenAccess，并创建了一个新的、丰富的VMI库LibVMI[^16]，它除了支持Xen之外还支持KVM管理程序[^17]，并通过使用多个优化的缓存来提高整体性能。值得注意的是，LibVMI集成了流行的内存取证框架V  olatility[^18]，因此受益于它的内存分析能力。

Virtuoso[^19]是一个先进的VMI技术，通过自动化的弥补语义鸿沟和制作out-of-VM工具，不需要关于guest OS的逆向工程或先验知识。关键是重现指令执行。 

存在的局限：

* 语义信息依赖于guest OS的版本：若os更新，语义可能也需要更新；
* 内核符号可能被破坏：DKSM攻击和DKOM攻击

### c. out-of-VM 派生：trap handling，trap forcing

硬件体系结构越来越多地涉及到提供现代操作系统功能，如多任务、用户权限、内存管理和保护、系统虚拟化[23][24]。虚拟机外衍生VMI的设计利用这些硬件提供的功能[25]，通过观察和解释硬件状态和事件来检查来宾操作系统的活动。这充分利用了虚拟机衍生的技术：操作系统不可知，能够抵御内核数据攻击和恶意软件规避。我们将这些VMI技术分为两个子类：一类是通过处理来宾操作系统活动本机导致的虚拟机监控程序陷阱来进行的（“基于陷阱处理”），另一类是通过使用基于硬件的挂钩强制陷阱进

#### 1) 基于Trap handling

通过设置VMCS相应的控制位，陷入trap。

Antfarm[^26]——第一个从x86体系结构派生语义信息的VMI系统——通过跟踪进程地址空间来跟踪进程的创建、切换和退出。这是通过跟踪对控制寄存器CR3的写入来实现的，控制寄存器CR3是一个硬件级进程标识符，指向当前运行进程的页面目录地址[23]。写入CR3会向虚拟机监控程序生成陷阱，因此允许Antfarm维护由CR3的观察值组成的进程列表。如果Antfarm观察到一个新的（相对于现有的）CR3值，它将检测进程创建（相对于切换）。当进程的所有内存页都未映射时，会检测到进程正在退出。通过限制CR3写入导致的陷阱数量，借助名为CR3目标值列表[23][27]的Intel硬件虚拟化扩展，可以减少Antfarm导致的VM性能损失。

Lycosid[^28]扩展了Antfarm，通过比较两个进程列表视图的长度来检测正在运行的隐藏进程，一个是使用VMI（trusted  view）构建的，另一个是通过来宾实用程序（如ps）获取的。在长度不同的情况下，每个进程CPU时间消耗的两个视图（对于Antfarm，两个上下文切换之间的时间消耗）的相关性允许识别隐藏进程（即受信任视图中的进程，其CPU时间消耗不会出现在In  guest视图中）。依赖于本机触发的VM出口的VMI技术的覆盖范围有限，因为有几个事件是内省感兴趣的–例如系统调用、内存访问…–不要自动捕获到虚拟机监控程序。

#### 2) 基于强制 Trap

利用基于硬件的hook对感兴趣的guest os的活动进行强制trap（中断、异常或fault），而本机不会产生VM-exit。

Ether[^29]是第一个利用VMI优势和硬件虚拟化扩展（如Intel VT-x[23]和AMD  SVM[24]）构建透明的虚拟机监控程序级恶意软件分析工具的系统，该工具能够检测和提取动态生成的代码，并跟踪恶意软件系统调用。

页面不可执行及影子页面。

评估表明，Ether可以成功解包所有最常用的打包程序（混淆器），并跟踪从混淆恶意软件调用的所有Windows系统调用。

Nitro[^30]是另一个基于VMI的工具，用于在x86体系结构之上跟踪系统调用。与Ether不同，Nitro具有更高的硬件和操作系统可移植性，并且产生的性能开销要少得多。

操作中断描述符表寄存器IDTR；

HyperTap[^31]依靠VM出口处理和强制跟踪进程、线程和系统调用，以便检测：

（1）在没有任何进程切换的情况下，当阈值时间过去时，来宾操作系统挂起，

（2）通过比较虚拟机监控程序和进程和线程的来宾视图，隐藏的rootkit和隐藏的恶意软件，

（3）集成忍者检查规则的权限提升攻击[32]。HyperTap通过处理写入CR3引起的陷阱来跟踪进程执行和每个进程的CPU时间消耗[26]。

对应于写入任务状态段（TSS）的线程切换跟踪是通过包含TSS的写保护内存页实现的，HyperTap使用新TSS中的堆栈指针作为线程标识符。最后，通过处理软件中断引起的陷阱来跟踪基于中断的系统调用，而通过将SYSENTER  EIP MSR中指定的处理程序地址设置为不可执行来跟踪快速系统调用。

存在的局限：guest OS活动的可见性仅限于硬件在其实现中所涉及的活动。因此，这种可见性限制了可能的VMI应用程序的范围。

### d. 混合方法

混合VMI技术结合使用虚拟机内、交付和衍生技术，以实现更高的健壮性、可靠性，并扩展可能的VMI应用范围。

#### 1) Trap forcing-based

Seshadi等人提出了一种半虚拟化和支持VMI的虚拟机监控程序，称为SecVisor[^33]，旨在确保移植Linux操作系统的内核代码完整性，并在其整个生命周期内**防止代码注入攻击**。SecVisor需要在**交付的源代码中重新实现引导、内核模块加载和卸载功能**，以使它们向SecVisor启动超级调用，SecVisor使用基于白名单的策略批准（或不批准）要加载到内存中的内核代码。SecVisor使用AMD  SVM[24]衍生的嵌套页表（NPT）机制提供的硬件内存保护，以保护经批准的内核代码免受非法修改和执行的攻击。

#### 2) Data redirection / memory shadowing

Riley等人提出了NICKLE[^34]，这是一个基于vmi的系统，构建在Qemu[35]之上，旨在防止使用内存阴影方案执行内核级rootkit。评估表明，NICKLE可以有效地检测和阻止已知的Windows和Linux  rootkit的执行，这些rootkit注入并执行恶意内核代码。然而，由于它是构建在软件仿真器之上的，因此NICKLE带来了**相当大的性能开销**。

Fu和Lin提出了VMST[^36]，一个基于双虚拟机的内省系统，通过将安全虚拟机(SVM)的监控工具(例如ps,  lsmod…)转换为程序来内省具有相同操作系统版本的来宾虚拟机(GVM)的内核数据，它能够自动桥接语义上的差异。与Virtuoso[19]需要执行培训才能生成内检工具相反，VMST自动重用SVM监视程序的二进制代码，并将它们对内核数据的访问重定向到GVM的内存中，而不是SVM的内存中。

为此，VMST在支持向量机监控工具(文件访问、网络访问、进程控制……)中检测内检相关系统调用的第一个执行上下文，然后识别可重定向的内核数据，最后执行重定向到GVM的内存。VMST通过检测系统调用的相应指令(如SYSENTER、SYSEXIT、INT  0x80、IRET)的执行来检测系统调用的开始和结束。在支持向量机监视工具执行系统调用期间，VMST通过标识对内核全局变量指针的访问，以及使用在线污染分析技术[37]从这些指针派生的访问，来标识可重定向内核数据。在虚拟地址到物理地址的转换过程中，通过使用GVM的物理地址而不是SVM的物理地址来重定向对已识别的内核数据的访问.

上述[19][36][38]中介绍的基于双VM的内省技术可以成功地弥合语义鸿沟，但是，由于在软件仿真器Qemu上进行大量的执行分析，它们会带来巨大的性能开销[35]。

#### 3) Process transplanting

Gu等人提出了**process implanting**[40]，这是一种通过在来宾操作系统中植入自包含的自省程序来实现主动VMI的技术。关键思想是在受信任的操作系统上编写一个程序，以实现所需的监控任务，然后静态编译该程序，以创建一个可执行文件，其中包含监控代码以及监控所需的可信版本的操作系统库（已交付）。为了执行VMI，虚拟机监控程序在来宾操作系统中选择一个随机进程，保存其上下文并用一个内省程序替换其代码。这样，牺牲品进程的调度将导致在VM中执行内省程序。这种技术避免了语义鸿沟问题，但是，如果受害者进程被安排的机会很小或很重要，则**随机选择受害者进程会使内省无效或有害**。此外，这种技术**容易受到DKOM和DKSM攻击**，因为静态链接到植入的内省进程的操作系统库无法处理内核数据结构的恶意操作。



Srinivasan等人提出了进程外移植[^41]，这是一种进程植入的反向方法，包括将可疑进程从来宾操作系统移植到主机操作系统。我们的目标是使用主机操作系统级别的传统安全工具（如syscall  tracer、antivirus等），在检查移植外的进程时避免语义差异。为此，虚拟机监控程序在主机操作系统上创建一个虚拟进程，以保存外接进程的上下文（即其处理器状态和映射内存页）。

因此，调度虚拟进程将导致执行外接进程。为了保护主机操作系统不受外接进程的影响，虚拟机监控程序只允许其用户级代码在主机操作系统上执行，并将其系统调用和页面错误重定向回来宾操作系统。为此，hypervisor对移植的进程隐藏syscall接口，以强制它捕获syscall调用尝试（派生的）。hypervisor随后将syscall调用转发给来宾操作系统，更具体地说，转发给一段代码（stub）——在VM中——插入到移植进程的原始映像中，以处理syscall调用。虚拟机监控程序将共享通信缓冲区中的系统调用号和参数传递给该存根。当在来宾操作系统中调度外接进程时，存根将调用syscall，然后存根将返回的值传递给hypervisor。最后，虚拟机监控程序将系统调用的结果传递给主机操作系统中的外接进程，并继续执行其用户级代码。虽然这种方法避免了监视可疑进程行为的语义差距，但它不适合**实时监视**整个VM。

#### 4) Function call injection

Carbone等人提出了Syringe[42]，这是一种内省方法，旨在将虚拟机外内省技术的安全性与虚拟机内内省技术的稳健性结合起来。Syringe填补了语义鸿沟，并通过从安全VM hook对来宾操作系统API（在VM中）的函数调用并检索它们返回的数据来获取有关来宾操作系统活动的信息。为此，Syringe在所选代理进程内的所选指令上设置一个断点（派生）。当此指令捕获时，Syringe保存代理进程的上下文，将EIP寄存器设置为要调用的函数的地址（假定为已知-已传递-），并将函数参数和返回地址（断点地址）推送到代理进程的堆栈中。然后Syringe继续执行VM以执行函数调用。当函数完成其执行并尝试返回代理进程代码时，由于返回地址上的断点，另一个陷阱将被强制进入Syringe。然后，Syringe检索函数返回的数据，恢复代理进程保存的上下文，并恢复VM的执行。通过这种方式，Syringe可以使用其API获得有关来宾操作系统状态的信息，而性能开销可以忽略不计。但是，由于来宾操作系统中的**监控功能数量有限**，其监控应用程序受到限制。此外，Syringe不能像其他纯粹脱离VM的内省系统那样**对入侵做出反应**.

Fu和Lin提出了HyperShell[^43]，这是一个基于VMI的shell，基于系统调用作为用户级应用程序使用来宾操作系统内核服务和管理其低级状态的接口的观点。因此，使用来宾操作系统调用作为虚拟机监控程序的接口将使其能够管理来宾操作系统的低级状态。HyperShell的工作原理如下：主机操作系统管理员在HyperShell中执行shell命令（例如ps、lsmod…）。Hypershell使用**动态库插入技术**拦截shell命令调用的系统调用[44]。与进程创建、动态库加载、内存管理和屏幕输出（已交付）相关的系统调用在主机操作系统上执行，而其余的系统调用（称为R-Syscalls）则由来宾操作系统内的辅助进程（在VM中）注入和执行。HyperShell通过共享内存将R-syscalls编号和参数传递给助手进程。助手进程随后调用所需的系统调用（派生），并发回返回的数据。因此，HyperShell可以产生所需的shell命令效果，就好像它们是由经过身份验证的管理员从来宾操作系统内部启动的一样。HyperShell产生的性能开销非常低并且不会对VM及其应用程序的执行产生影响。这些优点使得HyperShell方法在现实世界中非常实用.

## 3. VMI的实际应用

在本节中，我们将重点介绍迄今为止探索的各种VMI应用程序概念验证。我们还简要介绍了如何使用我们在上一节中介绍的VMI技术来进行他们的方法。

### A. 入侵检测

VMI使虚拟机监控程序能够了解虚拟机的活动并观察其状态的变化。因此，虚拟机监控程序能够检测由于违反预定义安全策略的入侵而导致的活动和更改。

[1]  [12][13][16][19]读取反映有关正在运行的进程、打开的文件和套接字的信息的内核数据结构。

[26][28][31]通过处理对CR3寄存器的写入来监视进程的创建和切换，从而检测隐藏的运行进程。

[31]陷阱写入TSS以检测线程切换，并通过挂接SYSENTER  EIP  MSR指向的处理程序的执行来跟踪系统调用。

[36][38][39][42][45]使用系统调用重定向和注入来读取和修改VM状态（例如进程、文件、套接字…）。

[46]通过捕获易受攻击代码的执行并对其应用谓词来检测易受攻击代码的攻击。

[47]检查已加载内核模块的签名和信息（例如地址、大小），以检测将代码注入内核空间的内核rootkit。

### B. 入侵防御

虚拟机监控程序对虚拟机状态和活动的感知使其能够检测虚拟机内部的入侵，并将这种感知与基于硬件的挂钩（例如断点、内存页保护标志的操作、非法指令注入等）相结合允许虚拟机监控程序超越检测范围，并在漏洞攻击尝试发生时立即阻止它们。

[8][9][40][41]通过挂接函数调用来监视进程行为。

[33][34]通过捕获和验证内核代码的加载和执行来防止内核rootkit。

[48]根据拥有相关套接字的进程，允许或阻止在虚拟机监控程序级别观察到的新网络连接。

[49]通过捕获对内核数据结构的写入并阻止违反预定义访问不变量的写入，防止以动态内核数据为目标的rootkit。

[50]通过监视第一个缓冲区分配，然后对其进行写入，防止缓冲区溢出攻击。

[51]通过在为已知存在漏洞的进程交付的网络数据包中查找已知的漏洞攻击签名，防止基于网络的漏洞攻击。

### C.恶意软件分析

除了恶意软件检测和预防之外，VMI还进一步扩展了虚拟机监控程序的功能，使其能够深入检查可疑和恶意进程的行为，

[29][30]通过挂接其调度程序来跟踪调用的系统调用，

[29][52]通过捕获修改内存页的执行来检测和提取动态生成的代码。

### D. 内存取证

支持VMI的虚拟机监控程序可以在语义上观察和解释VMs内存中的内核和用户空间。通过计算代码页的基于散列的签名，虚拟机监控程序可以识别良性和恶意代码页[53]、运行进程的标识[54]以及来宾操作系统内核的确切版本[55]。此外，虚拟机监控程序还可以通过挂接和监视对内存页的写入来生成内存修改映射，以报告哪些进程进行了哪些修改[56]。

### E. 虚拟机subverting

当VMI被提议用来保护信任底层虚拟机监控程序和硬件的虚拟机时，恶意虚拟机监控程序可以利用VMI技术，通过改变已执行指令的语义来获得对虚拟机的未经授权的访问（例如，当将正确的密码与错误的密码匹配时，使cmp指令返回true）或者通过在身份验证系统内更改被调用的系统调用返回的数据（例如，将从/etc/shadow文件读取的数据替换为与输入的密码相对应的数据）[57]。

### F. 虚拟机管理和配置

正如前面在Exterior[38]和HyperShell[43]中介绍的，VMI支持创建一个脱离VM的外壳，该外壳允许管理和配置VM，而无需在VM内部进行身份验证。

### G. 用户层应用自省

VMI的工作重点主要是弥合与内核代码和数据相关的语义鸿沟，以保护来宾操作系统。最近的工作研究了通过分析内存访问模式[58]或模糊数据结构[59][60]，弥合与用户级应用程序相关的语义鸿沟，以定位重要的数据结构（例如URL、加密密钥、游戏分数、应用程序设置等）。

### H. 实时调度

VMI的工作重点主要是弥合与内核代码和数据相关的语义鸿沟，以保护来宾操作系统。最近的工作研究了通过分析内存访问模式[58]或模糊数据结构[59][60]，弥合与用户级应用程序相关的语义鸿沟，以定位重要的数据结构（例如URL、加密密钥、游戏分数、应用程序设置等）。

## 4. 讨论

图1展示了我们对VMI技术和应用的分类，以及这些技术和应用多年来的发展。

![image-20211129150836409](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211129150836409.png)

1）在弥合语义鸿沟时需要信任的组件和信息源，以避免对VMI技术的攻击。有几种VMI技术假设一个不受信任的操作系统仍然报告有关其活动的正确信息，因此它们容易受到多重攻击，因为它们根据不受信任的信息；

2）可移植性做出决策，在同时监控大量异构虚拟机平台时，VMI技术的可扩展性和性能：大多数VMI技术设计为只监控一个虚拟机，只支持特定的操作系统。此外，即使只监控一个虚拟机，它们产生的性能开销也很重要，只有少数工作通过研究更实用的虚拟机接口技术来解决监控大量虚拟机的问题

3）用户隐私：在现有虚拟机接口技术的设计中，虚拟机用户的隐私被忽略。这是一个问题，因为支持VMI的虚拟机监控程序可以从内核和用户空间读取或提取用户敏感信息，并且可以在用户不知情的情况下未经授权访问用户虚拟机。在对公共云采用自省时，应考虑用户数据隐私。