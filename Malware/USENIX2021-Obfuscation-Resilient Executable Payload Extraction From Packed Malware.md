# Obfuscation-Resilient Executable Payload Extraction From Packed Malware（USENIX 2021）

## 摘要

1. 恶意软件的api为它的恶意行为提供了丰富的信息->API混淆（移除PE头文件的导入表信息，使API调用名称的解析变得复杂）->即使获取到解压缩的代码，也无法使用反编译工具正确识别其导入的API名称并且无法成功执行。
2. 本文目标：从经过压缩和混淆的二进制代码中恢复一个可执行的恶意软件程序。
3. 基于程序到达OEP（Original Entry Point）时的进程内存，实现了一个硬件辅助的工具API-Xray。
4. 本文的优势：更好的抵抗多种多样的API混淆方法，覆盖更多解析的Windows API名称，成功重建了155,811个executable malware，并且大幅提高了7,514个未知或新的恶意软件变体的检测率。

## 1. 研究背景

### pack1与unpack1

二进制文件packing技术的发展有两个特征：

1. packed malware开始运行时，其中的解压缩程序会通过多层自修改代码，直到到达了载荷（payload）的OEP；
2. 复杂的packer经常合并了多种反分析方法，包括反调试、反hook、反沙箱，来阻碍自动和手动地unpack尝试。

从防御角度来看，大部分研究依赖**内存访问追踪**来寻找OEP，接着dump当前进程内存作为解压缩的程序。

BinUnpack，提出了一种有效的启发式方法来快速确定多层解包的结束，而无需大量的内存访问跟踪；但是许多unpacked程序无法运行，这个问题是当前存在的unpack方法的通病。原因是解压缩的代码的**导入表**是损坏的。

### PE-IAT&INT

Windows的恶意软件通过调用API达到一些恶意目的，如远程代码注入和C&C交互。

* **IAT(Import Address Table)**是一个寻址表用于调用Windows API；PE文件的API callsites通过间接调用指向IAT。

* **INT(Import Name Table)**包含了对应于IAT条目的API名称，可以视为IAT的索引。

通过INT，Windows PE加载器使用对应的API虚拟地址填充每一个IAT条目。

### unpack1与pack2

由于IAT和INT位于PE头，如果能够从一个malware的文件头获取这两个表，那么就可以猜测malware的功能；例如advapi32.dll，可能进行访问或修改注册表；“CreateRemoteThread” API经常用于进程注入。

packer也知道API的重要性，于是在packed PE中不使用标准的API解析。

**本文要解决的问题**

给定OEP内存，如何推理每个API调用点对应的真实API名称？

**优点**

1. 覆盖了本文**所有的API混淆方法**，能够对packed malware使用的所有API名称进行解析；
2. 许多研究使用API hooking或动态二进制插装方法来追踪一个API调用的的目标，但是恶意软件可以对这些监控环境进行**指纹识别**。

## 2. 本文方法

### 使用的技术

* Intel Branch Trace Store(BTS);
* NX bit(Non eXecution);

### 具体步骤

1. 首先使用**静态分析**，探索所有潜在的API调用；
2. 接着通过**API微执行**强制执行每一个API调用，不需要具体的函数参数；同时，使用**BTS**跟踪API调用的目标地址；
3. 此外，当控制流到达目标API时，开启NX bit，执行中断；
4. 接着，分析BTS记录，确定真实的API地址；
5. 最后，将获得的API地址与相应的API名称相关联，重建INT & IAT条目，并恢复PE头。

## 3. 预备知识

### 3.1 Packer如何避免使用标准API解析

**导入表工作原理**

a. 初始状态：编译器不知道导入的API地址，所以IAT填充0；需要注意的是IAT和INT的条目是按顺序一一对应的；

b. PE被加载时，Windows PE Loaer将需要的DLL映射到PE的内存地址空间，并根据INT的名称顺序一一填充IAT。

![image-20210706160051253](https://i.loli.net/2021/07/06/hMWnog3lxX1GLYC.png)

**删除导入表**

a. 在压缩恶意代码时，packer擦除INT和IAT条目，并使这两个表从PE头是**不可达**的；

b. 同时，在解压缩的部分维护一个移除的API列表；当真正执行程序时，执行原始代码前**恢复一个新的IAT**；

c. 最方便的实现方法是调用“LoadLibrary”和“GetProcAddress” API，在运行时**显式加载**一个动态链接库并获取一个应用编程接口地址。

**隐藏调用的API名称**

混淆API调用的使用和控制流。

### 3.2 现有工作的局限

### 3.3 利用硬件的控制流监控

**DBI(Dynamic Binary Instrumentation)**不能保持正在执行的代码完好无损，因此它们的检测环境很**容易被检测**到。

基于硬件的监控克服了这种缺乏透明度的局限，利用CPU功能来记录控制流，无需代码注入。

* Intel的三种硬件机制：Last Branch Record(LBR), Branch Trace Store(BTS), Intel Processor Trace(IPT)；
* 对本文来说，BTS是重建导入表的唯一选择。（为什么？？？下面会解释）

#### LBR

LBR可以将**16或32**个最近的分支对(源和目标)记录到寄存器中。

* 快速：直接访问CPU寄存器。

由于LBR堆栈的大小有限(16或32)，攻击者仍然可以绕过LBR的监控。

#### BTS

BTS将各种分支对(源和目标)记录到内存缓冲区中，用户可以确定内存缓冲区的大小和位置。

与LBR在LBR堆栈已满时**覆盖数据**不同，BTS可以配置为在**记录缓冲区已满**或**触发预定义异常**时**暂停**应用程序。

#### IPT

* 离线
* 不记录无条件直接分支（直接jmp和call）。

![image-20210712111147718](https://i.loli.net/2021/07/12/iNMOfu2ktJUpEsj.png)

## 4. API Obfuscation的深度分析

作者分析了BinUnpacker提到的29种packer，其中12种packer对API调用网和目标API EP之间的控制流进行了混淆。

![image-20210712144927527](https://i.loli.net/2021/07/12/n5q3eoSswGX47f9.png)

纯虚拟化工具不在本文研究范围，如Code VIrtualizer和VMProtect。

现有的导入表重建方法通常依赖于一些假设，这些假设可能无法反映高级打包程序的复杂性：

1. 目标API的地址在解压缩的代码中是**静态可识别**的；
2. 当控制流到达DLL时，应当导向目标API的EntryPoint；
3. API调用不得不通过**IAT**转发；

本文对以上三个假设分别进行了反驳：

1. 如图2 b)所示，使用结构化异常处理程序（SEH），首先执行一个触发错误的指令（除零），跳到另一处的SEH，最后SEH转发控制流到目标API；这种情况下如果仅通过静态分析，没有执行trampoline代码和SEH，则无法识别目标API地址；
2. 有三种情况无法满足，关键在于malware在进入目标dll时首先调用的并不是目标API（入口处），而是如反调试API、无效API以及在目标API入口后偏移若干字节：
   1. 一（Armadillo, PEP, and Obsidium）是fig 2 c)：在调用目标API前，先调用反调试API（定时检查或校验和）；
   2. 二是（PELock and Obsidium）fig 2 d)：使用ROP风格来重定向API调用；
   3. 三是2 e)，如 Themida, PELock, and Enigma：通过复制目标API开头若干个字节的指令，绕过API监控器通过在API地址进行hook的方法。
3. API调用不一定通过IAT。原始API调用通过间接调用（FF 15），那么重写为直接调用（E8），还可以再覆写一个字节。

![image-20210712145438168](https://i.loli.net/2021/07/12/5MLd7svGnjNFUTw.png)

## 5. 系统设计和实现

### 5.1 整体架构

1. **获取OEP内存**：使用现有的二进制Unpack工具 PinDemonium、CAPE或BinUnpack；
2. **内存静态分析**：探索所有可能的API callsites；
3. 强制执行每一个API从而高效的通过跳板代码(Trampoline)；同时底层硬件跟踪提供了一个透明的环境来捕获跳转到DLL内存页面的分支。
4. 二进制解压缩工具调用API-Xray作为一个自定义的dll，重构导入表（IAT和INT）；

![image-20210712154148983](https://i.loli.net/2021/07/12/LwM1vfgeij4aJH6.png)

### 5.2 内存静态分析

当到达packed malware的OEP时，首先使用WindDbg附加到程序，然后使用IDA的WinDbg插件反汇编OEP内存，之后，运行自定义IDA Pro插件，它遵循Eureka的搜索算法（A Framework for Enabling Static Malware Analysis. ESORICS’08），以探索所有潜在的API调用点。

定位所有间接call和jmp指令，包括以下部分：

1. 目标位于解压缩程序的控制流指令；
2. 间接jmp，访问一个swtich-case处理的表；
3. 通过标准IAT引用的有效的API；

然后，保存反汇编的代码以及解除WinDbg的附加（防止后续API执行时恶意软件的反调试）。

### 5.3 API微执行

>Patrice Godefroid. Micro Execution. In Proceedings of
>the 36th International Conference on Software Engineering
>(ICSE’14), 2014.

为了摆脱表3第二列中显示的复杂控制流并解析API名称，我们需要满足以下两个要求：

* 执行与每个API调用站点关联的trampoline代码，以便我们能够高效地通过冗长的来回跳跃（Micro Execution）；
* 捕获目标最终驻留在目标API代码中的控制流分支（BTS & NX bit）。

给定OEP运行时的上下文，trampoline代码可以单独运行。

为每一个API调用创建一个新的线程，当得到一个API名称时，再进行下一个API执行，这样不会造成任何冲突。

### 5.4 硬件辅助追踪

使用BTS，因为LBR只能记录16或32个分支，而IPT不能记录非条件分支。

在DLL的内存页面开启NX bit，并hook page fault handler，来为每一个异常复制记录的分支数据。

### 5.5 内核模块

1. 配置和开启BTS分支追踪；
2. hook用于开启和关闭以及检测NX的内核函数（对于不调用DLL的）
3. 当不可执行的中断在DLL页面被触发，对应的handler会采取以下操作：
   1. 通知用户模块保存当前栈帧，用于识别当前分支点是否导向目标API；（step 3）
   2. 复制BTS追踪的buffer到用户空间，用于后续分析，然后重置BTS buffer。（step 4）

### 5.6 进程过滤（step 5）

由于BTS追踪不是针对特定进程的，所以需要进行过滤。

当获取到程序的OEP内存，知道当前进程的内存地址范围，包括加载的DLLs。并且，有了OEP内存的反汇编，知道BTS记录的目标地址的指令是什么。

为了过滤其它进程产生的噪声，目标信息需满足以下三个条件：

1. 源地址和目标地址均位于我们的进程范围内；
2. 源地址的指令必须是分支指令；
3. 分支链的最后一条记录，从非DLL位置（trampoline code）转移控制流到DLL页面内。

### 5.7 目标地址校验

在前面提到，当控制流到达DLL时，不一定会到达目标API。

为此，需要对两种特殊情况进行针对的处理：

#### 1. 反调试(Anti-debugging Routine)

![image-20210712212931569](https://i.loli.net/2021/07/12/PZItbyHDzUig216.png)

给定一个分支的目标地址，作者使用两个信息来排除它：

a. 当一个动态链接库的不可执行中断被触发时，它的栈帧；

![image-20210712211325079](https://i.loli.net/2021/07/12/JH4kcWwqpKQUa3z.png)

b. trampoline基址。

由于调用完anti-debugging api后，控制流会返回到trampoline代码区域，继续执行后续代码。利用这一特点，此时栈上的返回地址的高位应与trampoline代码区域的地址高位相等，从而排除该目标地址为目标api的可能。

#### 2. ROP重定向(ROP Redirection)

反汇编目标代码，如果是类似ret的指令，则排除。

![image-20210712213248608](https://i.loli.net/2021/07/12/hdkQKnBWzZTPJMV.png)

#### 3. NX-bit Switch（step 6）

对于以上两种情况，则通知控制NX位的模块，关闭DLL页面的NX bit，开启trampoline的NX bit。

这样，当控制流返回到trampoline代码区域时，同样会触发page fault，此时handler可以控制NX bit在trampoline开启还是在DLL开启。

#### 4. 1-Branch Interrupt（特殊情况）

有经验的攻击者可以构造DLL内部的ROP chain，控制流会在DLL内部转移，直到到达目标API。

解决办法是当检测到ret类似的指令时，重置BTX buffer大小为1，使得BTS可以捕获DLL内ROP链的每一个分支。当然，这样做会使得开销增大。

![image-20210712164300664](https://i.loli.net/2021/07/12/puo5hryIk3xZjSU.png)

### 5.8 导入表重构（step 7&8）

对于Fig 2 e) 使用API的前几个字节的情况来说，目标地址不在目标API的起始位置。

1. 扫描DLL头的地址表，获取所有API的名称并计算地址范围；
2. 将目标地址与每个API的地址范围进行比较。

在完成所有可能的API微执行后，进行重构IAT和对应的INT。

针对Fig 2 f)的重写API调用的情况，需要通过新的IAT重写直接调用为间接调用。

## 6. 评价

* API-Xray在API覆盖率和API混淆对抗的效果上均优于现有工作；
* 与LBR和IPT相比，我们证明了选择BTS是导入表重建的唯一可行选择；
* 我们报告了在野外测试大规模打包恶意软件的经验。特别是，API-Xray推进了未知/新恶意软件的检测和分析；

### 6.1 比较评价

* Malware - Zeus Trojan：Compile in Win10
* Themida: 一个复杂的商业代码混淆器。
  * paching model: 代码虚拟化；
  * partial code revealing: 允许用户选择加密的源码，在运行时先解密代码，执行，然后再加密；

将API-Xray与BinUnpack、Ugarte-Pedrero和RePEconstruct进行比较。

#### 6.1.1 API覆盖率

结果如下图所示，Zeus原始有348个API。

* BinUnpack（静态）: Yoda 102, 因为yoda只混淆kernel32、user32和advapi.dll，这102个是没有被混淆的；
* SP（动态）：单次执行只有56个api，设计之初没有覆盖所有的api，依靠多次执行不同的输入可以到达更高的覆盖率；
* RP（混合）：在高级packer下覆盖率急剧下降。

![image-20210713092724289](https://i.loli.net/2021/07/13/jgMPlKw6TYkAOsp.png)

#### 6.1.2 对API混淆方案的对抗

![image-20210713102635225](https://i.loli.net/2021/07/13/ptDQFBqucaCSOri.png)

### 6.2 LBR vs. IPT vs. BTS

* LBR: 分支最多32
* IPT：不支持直接跳转指令
* 左 硬件追踪的运行时间 右 导入表重构的总时间

![image-20210713110521372](https://i.loli.net/2021/07/13/3BQRavEqbi68YHo.png)

### 6.3 对野外的packed malware进行大规模评估

> 从2019年7月到2019年12月，API-Xray已经部署到一家反恶意软件公司，与打包的恶意软件一起进行大规模评估。API-Xray被集成到商业拆包工具中，以帮助安全专业人员进行恶意软件离线分析。我们在生产环境中总共收集了341,269个打包的恶意软件二进制文件。其中74.6%受到已知包装商的保护，其他(25.4%)受到定制包装商的保护。

![image-20210713153758435](C:/Users/l1b0/AppData/Roaming/Typora/typora-user-images/image-20210713153758435.png)

![image-20210713103026362](https://i.loli.net/2021/07/13/MNQv2p9eIlzhj18.png)

* 使用IDA Pro扫描重构的PE，检查是否有未恢复的API，结果成功了98.4%（174,285）。未成功的样本原因在于调用了自定义DLL的API。如图Fig 7 b);

  ![image-20210713112037116](https://i.loli.net/2021/07/13/l6tQMF5Y3XbrcLk.png)

* 评估了APIXray输出的可执行性。我们在三个最先进的恶意软件沙箱中运行每个解压缩的PE文件:SecondWrite [67]、混合分析[22]和VMRay  Analyzer [78]。我们选择它们有两个原因:1)它们都报告样本是否是恶意的；2)由于这三个沙盒应用了不同的防入侵方法;

  ![image-20210713154528522](https://i.loli.net/2021/07/13/jWotSXkMGR4cNFg.png)



![image-20210713155249074](https://i.loli.net/2021/07/13/CMhg4SWyQOY1EDa.png)

## 7. 讨论

### 7.1 可能存在的攻击面

1. BTS：这种强制性的驱动程序签名使得恶意软件几乎没有侵入操作系统内核的空间。

2. NX bit

   ![image-20210713160501423](https://i.loli.net/2021/07/13/uxzo6RUe9HDlnZi.png)

3. 静态链接库：虽然可以绕过本文方法；但是它会在不同的Windows版本下导致不兼容的问题。第二，静态链接也损害了恶意软件的可移植性，因为它大大增加了程序的规模。

4. 在malware里复制整个API：将DLL页面设置为不可读。导致page fault，进而获取对应的API名称。

5. trampoline代码需要特定参数来跳转：此时需要符号执行探索正确的参数；

6. 虚假的API调用：在调用目标API前调用许多没用的API。这会增大API-Xray的开销，但是这个方法同样会增大程序本身运行的开销。


![image-20210713161115150](C:/Users/l1b0/AppData/Roaming/Typora/typora-user-images/image-20210713161115150.png?lastModify=1626165239)

## 相关资料

1. 恶意软件使用的API：https://fareedfauzi.github.io/notes/windows_api_in_reversing_malware/#

