# DETECT KERNEL-MODE ROOTKITS VIA REAL TIME LOGGING & CONTROLLING MEMORY ACCESS（2017）

## 1. 出发点

- 问题

  - malware会攻击现有的av软件甚至是微软的PatchGuard；
  - PatchGuard很容易受到内核级攻击，因为它与rootkit位于同一个环境(Yan, Luo, Feng, Pan， & Safi,  2015)。TDL4/TDSS rootkit家族通过修改系统的引导加载程序来禁用PatchGuard。

- 本文工作
  - 为了应对新的malware，本文提出使用Intel VT-x和EPT技术实时监控和控制对内存的访问；
  - 作者开发了一个原型MemoryMonRWX，一个裸机hypervisor，能够跟踪和捕获所有类型的内存访问（R\W\X）；
    - 优点：**细粒度**分析（指令级别的trap），支持**多核**cpu和**win10 x64**;
    - 创新点：保证每次内存访问的拦截，弹性和低性能退化。

- 威胁模型：
  1. Read: 窃取敏感数据，如密钥和私人用户数据；
  2. Write: 对内存内容的操作，例如hoook、unlink和patch；
  3. eXecution: 执行未知的代码片段。
- 初步的效果如下: 

![image-20211210101724977](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211210101724977.png)

- 测试结果
  - 性能开销10%

## 2. 研究背景

![image-20211210102614281](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211210102614281.png)

### 2.1 基于操作系统的内存监控方法

#### A. Hook内存管理函数

- Prakash(2015)通过hook内存分配和回收函数，即ntoskrnl.exe的ExAllocatePoolWithTag和ExFreePoolWithTag以及MmLoadSystemImage函数；
- Milković(2012)提出了在多核处理器系统上使用内联钩子稳定地截取内核模式函数的方法。通过将著名的修改指针值的技术应用到系统服务调度表(Matrosov,  Rodionov， & Bratus,  2016)，并使用隐形钩子技术和重定向存根来隐藏钩子(light等人，2014)，也可以钩子内核模式函数。
- 然而这些方法只能在32位的windows工作；
- 64位由于PatchGuard（Kernel Patch Protection，KPP）机制，保护关键内核结构不被未经授权的实体轻易修改（Block ，2015），并控制windows内核的完整性包括ntoskrnl.exe(Irfan et al., 2013; Comodo, 2013)。

#### B. 通过中断描述表IDT的页面错误例外（Page Fault Exception）

### 2.2 基于Hypervisor的内存监控方法

三类：

- 第一种方法使用Intel虚拟化技术(VT-x)，没有任何特定的特性。因此，这种方法甚至可以在传统的**Intel Core 2 CPU上**工作。
- 第二种方法是利用英特尔**VT-x和EPT技术**，该技术可用于第二代英特尔家族**i3、i5和i7**。
- 最近分析的一篇论文要求使用支持英特尔处理器跟踪(**PT**)技术的处理器，该技术只在**第五代以后的**最新cpu中集成。

#### A. Handling Page-Fault Exceptions by Hypervisor

该方法利用硬件虚拟化技术通过处理Page-Fault Exceptions来监视对内存的访问。

与前面的方法一样，该方法修改**页表条目或内存页的属性**，访问应该受到控制。对该页面的任何访问都将生成#PF并导致**VMexit**，这将由hypervisor处理，

![image-20211210105155003](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211210105155003.png)

##### 相关工作

- Kuniyasu等人(2014)提出了DriverGuard hypervisor，以保护工业基础设施系统免受Advanced Persistent  Threat  (APT)的威胁。
  - 作者认为，大多数这些威胁“都是**0Day攻击**，基于**签名**的安全工具无法检测到这些攻击。
  - ”它们的管理程序“防止恶意写访问导致Windows蓝屏死机的代码区，以及恶意读写访问导致信息泄漏的数据区”。DriverGuard管理PTE并改变当前位(P位)。因此，所有对该页面的访问都会导致一个页面错误，该错误被DriverGuard钩住;它分析访问是否来自合法的代码。如果一个合法的代码访问内存，DriverGuard将应用一个新的隐形断点技术，在单步模式中使用硬件断点。
  - 它通过在VMCS中设置监视器Trap标志(MTF)位来启用单步模式。DriverGuard使用“标签”值识别具有敏感数据的内存区域。由ExAllocatePoolWithTag动态分配的内存区域若包含“tag”值，则受到保护。
  - malware可以窃取tag值并将其应用在malware上。
  - 作者承认，页面错误比软件中断慢，而且“会降低性能”。

- MOSKG, by Yan, Luo, Feng, Pan, & Safi (2015). 
  - 防止rootkit通过DKOM和页面映射攻击操纵关键的内核数据；
  - 主要的挑战：
    - 动态的数据会被OS合法的修改以及rootkit非法的修改；
    - 如何区分操作是**合法or非法**？
  - 解决方法：
    - 影子页表SPT标记机器页，而包含受保护数据的机器页是只读的；
  - 存在的局限：
    - 保护范围不够；
    - rootkit会通过寻找其它不受保护的数据来危害OS；

- 在基于管理程序的系统HyperSleuth中使用了类似的处理页面错误的方法，用于跟踪系统调用(Martignoniey al  2010)。
  - 因为所有的系统调用调用都要经过一个公共门(其地址由SYSENTER_EIP寄存器定义)，所以这些工作线程将这个寄存器的值和影子拷贝的值映射到一个不存在的内存位置的地址。
  - 然后，所有系统调用调用都会导致页面错误异常。
  - 因此，HyperSleuth捕获并保存所有系统调用到日志，然后通过网络传输到可信主机。
- VMI机制捕获系统调用(Pfoh等人，2011年)。这个Nitro系统工作与以下系统调用:
  - 用户定义中断;和SYSCALL /  SYSENTER指令。
  - 这个系统不能监视内核模式下的函数调用。

- Yan(2013)通过虚拟化进行了恶意软件分析，并证明了这种内存监控方法对DoS  (Denial-of-Service)攻击是没有弹性的。
  - 问题是恶意软件可能会引发大量的页面错误异常，而每个异常都涉及到管理程序的退出。
  - 这种异常泛滥会对记录的日志发起DoS攻击，并使进一步分析变得困难。

- Memory Trap的方法的缺点：
  - 不是隐形的:页面属性或PTE.flags的修改在guest中是可见的，很容易被恶意软件揭露;
  - 不轻量级：每一个page fault会产生处理的时间，巨大的性能开销；
  - 不完全支持多核CPU, 因为一个PTE只有一个页面，被所有核共享；

#### B. Intel Extended Page Tables technology

EPT技术（Second Layer Address Translation，SLAT）的优势：

- 通过页面管理的硬件优化来降低内存和性能开销；

EPT分页结构的内容和组织类似于受保护模式或x86-64页表中的分页结构。然而，EPT和guest分页结构之间的内容有几个不同之处(Grehan,  2014)：

- 如图5所示，EPT分页结构包括以下表:
  - Page Map Level 4 (EPT PML4)
  - Page Directory- pointer Table (EPT  PDPT)
  - Page Directory (EPT PD)
  - Page Table (EPT PT)

- 在来宾操作系统(来宾操作系统)内的每次内存访问期间，最初都涉及来宾分页数据结构。最后，EPT结构将接收的客户物理地址转换为主机物理地址。
  - 可以通过修改EPT page表中相应项中的**位**来拦截对该页的内存访问，而其他表中的项EPT PML4、EPT PDPT和EPT PD有它们自己的默认值;
  - EPT Page Table Entry提供了bits，控制是否允许访问相应页：
    - bit#0：Read-Access,表示是否允许从4KB页面读；
    - bit#1：Write-Access,表示是否允许从4KB页面写；
    - bit#2：Execute-Access,表示是否允许从4KB页面取指令；
  - 根据Intel手册2016，任何被拒绝的访问尝试都会产生EPT violation，并产生VM exits；此时Hypervisor可以中断每个VM exit，并实现相应的算法来提供安全措施。

![image-20211210140830858](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211210140830858.png)

##### 相关工作

- 2014.动态分析系统DRAKVUF
  - 基于Xen，LibVMI；
  - 能够跟踪执行并解决DKOM攻击，自动化跟踪OS执行并且trap所有内核函数：
  - 关键技术是对感兴趣的代码处写入0xCC，
  - 仅支持Windows 7 32bits和64bits；
- 2012.CXPInspector
  - 基于KVM，QEMU;
  - 从外部分析vm的状态；
- 2014.HyperTap
  - 基于KVM和Linux kernel
  - 功能：监控各种系统事件和状态，能够Trap上下文切换，系统调用，指令执行和内存访问；
  - 方法：为分配的memory Mapped I/O区域设置内存保护，以便对该区域的访问将触发EPT_VIOLATION事件。
  - 应用场景：
    - 隐藏的rootkit检测: 设置内存访问权限跟踪线程切换；将所有包含TSS结构的内存页设置为写保护。线程切换时会修改Task State Segment，于是产生VM exit，进而进行安全防护；
    - 权限提升检测
  - 支持Windows XP，Vista, 7;
- 2016.Uty & Saman-将hypervisor和EPT应用在rootkit
  - 出发点：不可见的inline hook对代码段的修改；
  - 方法：
    - 通过1:1的映射方式将来宾物理地址映射到主机物理地址。
    - 复制物理和原始页面，避免完整性检测；对原始页面注入0xCC，复制的页面没有修改。
  - 结果：实现了keylogger，并且绕过了PatchGuard；在Win 7 x64和8.1 x64进行了测试；
- EPT的缺点：
  - 粒度：页面粒度，没有细粒度分析；
  - 没有一种解决方案能够同时监视和控制所有可能的内存访问:读、写和执行；
  - 所有分析的安全解决方案都不灵活，因为它们都基于大型平台，如Xen、KVM、QEMU等。

### 总结

以上工作的缺点：

- 基于OS的方法都容易受到rootkit的修改；
- 基于page fault的方式不够**轻量级**，并且不支持**多核**；
- 基于EPT的方法既不提供**细粒度分析**，也不提供**捕获所有内存访问**的能力。

![image-20211210143632871](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211210143632871.png)

## 3. 本文工作

- 第一个可以捕获客户操作系统的**一个字节修改**的内存监视系统，而其他所有解决方案都是在**页面**粒度级别上工作的；
- 在Windows 10 14393 x64上测试；

### 3.1 应用EPT技术来Trap和控制内存访问

#### 场景

1. 监控可疑驱动的内存访问，从已知的地址范围加载的；SRC
2. 可疑内存地址的访问被控制；DST

#### 方法

- 使用源地址范围（SRC）和目标地址范围（DST）。
- 只监控SRC到DST范围的内存访问。
- 使用EPT结构，我们可以实现从SRC范围到DST范围的内存访问控制，并跳过所有其他访问，参见图6 a)：
  - 1.GVA->GPA
  - 2.GPA->HPA
  - 3.disallowed memory acces->VM-Exit
  - 4.log & control 对内存页面的访问；

![image-20211210145254869](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211210145254869.png)

具体来说，进行以下五个步骤，通过重置X位控制来自SRC范围的内存访问，然后过滤所有这些访问中到达DST范围的访问，通过重置RWX。

##### Step1：Trapping SRC Range execution

为了将所需的访问从所有内存访问中分离出来，设置EPT结构如图7-a。

使得所有在**SRC范围的执行访问**被拦截。

##### Step2：SRC-eXecution ==> VM-Exit

在EPT指针更改时，更新EPT结构为图7-b。

使得当代码试图访问DST范围时，hypervisor收到VM exit。


![image-20211210151020099](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211210151020099.png)

##### Step3：DST Access ==> VM-Exit

对于陷入和监控内存访问的需求，需要记录所有相关信息：*SRC地址、DST地址、访问类型（RWX）和被读写的字节流内容*。

为此采取三个步骤：

1. 将保护页面的EPT.PFN的值转移到另一个页面，例如空页面；
2. 将该页面的访问权限设置为EPT.DST.read and write；
3. 设置Monitor Trap Flag；
   * 使得系统在执行每条指令后生成VM Exit系统。
   * 在guest OS读取替换后的页面然后执行一条指令时，由于VM exit，控制权转移到hypervisor，接着到达Step4；

##### Step4：MTF ==> VM-Exit

到达此步骤，可以保护数据或代码不被读取和篡改。

为了截获新的内存访问，需要对Step3的配置进行恢复：

1. 重载原始页面的EPT.PFN值；
2. 重载EPT.DST.read和write为false；
3. 清除MTF；

在这之后，任何对DST的访问会产生VM exit，然后回到Step3；

而对OTH的执行访问也会产生VM exit，此时到达Step5。

##### Step5：OTH eXecution ==> VM-Exit

判断VM exit地址是否在SRC范围内，若不是则意味着不在保护范围内，于是将EPT结构从monitor改为normal，回到Step1。

##### 总结

![image-20211211100206993](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211211100206993.png)

![image-20211211100223709](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211211100223709.png)

### 3.2 架构和主要组件

MMRWX的组件如下图的蓝色背景块所示，HyperPlatform, Image Load Detector, Source/Destination Range Manager (Src/Dst Range Manager)，Virtual-To-Physical Map Manager (V2P Map Manager)和EPT controller。

- **HyperPlatform(HP)**: 一个裸机hypervisor，设计用于中断guest OS的活动；
  - 在2016 REcon被Tanda & Korkin首次提出；
- **Image Load Detector(ILD)**：在MMRWX加载后，ILD形成一个guest 虚拟内存地址的SRC和DST内存范围，包括以下类型：
  - 关键内存区域的地址；
  - 最近加载的驱动地址；
- **Src/Dst Range Manager(RM)**: 接受来自带有Src/Dst虚拟地址范围的ILD的请求, RM要求EPT controller更新相应范围的EPT设置，使得当guest OS驱动从SRC尝试访问DST范围时产生VM exit；
- **V2P Map Manager**：维护虚拟地址(VA)到物理地址(PA)的映射。
  - 接受来自SRC和DST范围的添加VA的请求，并将相应的PA进行存储；
  - 一旦发生以下事件时，HP请求V2P校验是否有VA:PA需要刷新；
    - TLB flush，由于缺页产生的Page Fault；
- **EPT controller**：在配置的内存区域产生to/from的访问时，操纵来宾操作系统的行为。
  - 负责初始化和更新EPT页面数据结构、处理EPT violation、记录内存访问；
  - 细粒度的访问控制通过拦截对内存页的访问实现。
    - 只有在配置的地址范围产生的EPT violation，才进行logging；

![image-20211210111817868](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211210111817868.png)

记录的日志保存在*C:\Windows\MemoryMon.log*，示例如图10。

- 符号解析通过用户层的parser(Tanda, 2016);
- 由于非image区域的执行不是都由call指令触发，返回地址的记录有可能出错：例如ret=0x4;

![image-20211211103029236](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211211103029236.png)

MMRWX的代码量约为12,000行，是Xen的3%不到。

![image-20211211103656097](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211211103656097.png)

### 3.3 测试

#### RWX三方面测试

##### Write-特权升级的内核漏洞（检测写）

典型的内核模式rootkit通过重写代码来钩子函数，并通过DKOM断开它们的结构链接。

这种攻击也称*Semantic Value Manipulation(SVM) attacks*。

![image-20211211105126768](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211211105126768.png)

例如CVE-2014-0816，修改了HalDispatchTable的值。为了防御，需要预定义范围。

MMRWX也可以用来保证关键内核段的完整性。

##### Read-防止PatchGuard被禁用(检测读)

2013，Ladakis通过读取kbdhid.sys的DEVICE_EXTENSION来拦截按键。

- 攻击：2016.Tanda的内核模式攻击”Disarms PatchGuard“，它读取nt!PoolBigPageTableSize，其中存储了大页面池。
- 防御：将地址范围配置为nt!PoolBigPageTableSize，当产生读访问，则返回一个空页面。

![image-20211211105524084](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211211105524084.png)

##### eXecution-检测rootkit执行（检测执行）

另一种rootkit攻击是将malware的可执行代码移动到driver段外面。

- 攻击：Turla rootkit (also known as Uroburos rootkit)；
- 防御：MemoryMonRWX能够检测非分页池的执行，以及执行的区域包含unpacked的rootkit代码；

#### 性能测试

- 系统：Windows 10 64bits；
- 软件：Novabench，PCMark8 Home；
- 结果如图14：
  - Graphics Tests的开销超过10%：作者猜测是活跃的内存访问导致频繁TLB刷新。
  - 其它的性能下降在10%以下。

![image-20211211110431757](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211211110431757.png)

## 4. 总结&未来工作

### 改进的点

- 保护的内存范围需要用户指定：
- 正常的操作会不会被报：

