# Lost in the Loader:The Many Faces of the Windows PE File Format（2021 RAID）

1. 存在的问题

不同的工具对于**PE文件格式的解析**存在细微的差异，这些差异可以被攻击者利用，从而绕过检测或逆向。解决这个问题的方式往往是研究人员手动的尝试并解决。

也就是能够在系统正常执行但是被分析工具视为畸形的文件从而不分析。==> 分析工具解析PE的方式和os不同造成的。



此外，Kim在2017年发现av产品解析和验证签名PE文件的方式的一系列问题：

* malware包含从良性程序复制的签名，则不分析；
* 程序有签名，不分析，从而节省时间；



本文开发了一个框架，用于捕获关于不同软件如何解析、检查和验证一个文件是否符合一组规范；并制作不同windows版本和不同av软件的加载器模型；最后，使用这个框架可以自动化的对某一个模型生成新的样本。



## 1. 介绍

现有工作：

fuzz：fuzzing PE header，产生可执行的文件，但是文件头的数据需要存在一些约束，导致这种方法产生的结果很有限。

开始于Microsoft Windows的不同版本(Windows XP、Windows 7和Windows  10)中使用的操作系统加载程序。对于每个版本，我们编写了一个模型，列出了执行的检查和操作，以确定

1)文件是否是一个有效的PE，因此应该“加载”到内存中;

2)加载过程如何从文件中提取和解析信息。

### 可移植的文件格式

> https://docs.microsoft.com/en-gb/windows/win32/debug/pe-format

1. MZ Header: 

<img src="http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211203195338888.png" alt="image-20211203195338888" style="zoom:80%;" />

#### PE格式的约束和含糊之处

> PE Format规范未能传达的是，当可执行文件不满足此类约束时将发生什么。换句话说，规范没有解决以下问题:“如果一个节不是以倍数开头会发生什么?

总结，PE格式规范没有明确规定在什么情况下文件应该或不应该被认为是有效的PE可执行文件，也没有提供明确的指导方针来处理极端情况。



## 2. 现有的解析文件格式的方法

### 2.1 对PE可执行文件的基本操作

#### 结构化检查

目的：确保文件遵循PE格式的基本结构。

检查的力度是一个考量的因素。

若检查失败，是继续解析还是直接退出。

#### 合规检查

目的：确保PE可执行文件符合特定于软件和特定于体系结构的约束。

例如，COFF  Header的**Machine**字段指定可执行文件要运行的**CPU类型**。操作系统可以使用这个字段来确定一个程序是否可以在当前CPU架构上执行。

遵从性检查通常是严格执行的，违反它们的约束通常会导致拒绝文件的执行。

#### 内存映射

目的：创建适合执行的PE文件的内存表示来准备进程地址空间。

该映像包括使用从可执行文件的不同部分提取的数据初始化的内存区域，映射在进程地址空间但未初始化的内存区域，以及对每个内存区域的内存访问权限的描述。

### 2.2 现有软件的方法

#### OS Loaders

目的是将程序的映像载入内存。在Windows操作系统中，“PE加载器”不是一个定义良好的自包含组件。

如图3所示，在将PE可执行文件装入内存的过程中，有两个不同的部分。

第一个是嵌入在Windows内核中，并为新进程分配内存，以及识别它的内核结构。加载过程的这个阶段还在新进程中加载ntdll.dll库。一旦第一个组件完成了它的任务，新进程的执行就从ntdll.dll中的一个函数开始，该函数启动加载进程的第二部分。

这两个阶段都对PE头进行结构和合规性检查，而结构检查通常严格地对所有头进行。一旦加载器收集了它需要的信息，它就继续分配和填充程序所需的内存。

换句话说，操作系统加载程序需要执行上面描述的所有三个基本操作。

这一点，加上它们是在两个不同的组件中实现的事实，使得这类软件成为最复杂和最具挑战性的分析对象。

![image-20211204101808916](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211204101808916.png)

#### 逆向工具

目的: 软件二进制分析。

为此，他们需要从PE头收集信息，以重新创建类似于操作系统加载程序可能产生的内存表示。

这意味着他们最感兴趣的是**内存映射**，并且经常使用最有效的方法执行结构检查。

例如，它们可能依赖于存储在debug  Header中的调试信息(如果debug  Header可用)，但如果此类头不存在或格式不正确，则返回到其他启发式方法。

另一方面，为了能够分析尽可能多的可执行文件，这类软件执行很少的合规检查。

#### 反病毒软件

目的：对从可执行文件的PE头中收集的信息执行**结构和合规检查**。

这些约束旨在确保可执行文件提供其特定于格式的签名所需的数据。

然而，它们可能执行很少的内存映射操作，通常只是为了使签名能够将RVAs转换为原始可执行文件中的偏移量(例如，yara[43]中的rva_to_offset函数)。

## 本文方法

> 由于前人的方法集中在黑盒方法，通过构造异常文件，观察目标（OS，软件）能否正常处理。
>
> 局限：只能处理简单的情况，并且覆盖面不足，无法列出所有可能的差异。而当无法发现差异时，就不可能判断两个应用解析PE的方式是否相同。

### 构建约束模型

以下三类操作可以模型化成为输入的约束:

* 结构化检查：magic numbers，强制性头（”MZ“, “PE”）；
* 合规检查：支持的ISA(Instruction-Set Architecture)，支持的os版本；
* 内存映射：生成内存映像；

![image-20211203153730056](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211203153730056.png)

#### 约束提取

目标：the MZ
header, the COFF header, the OptionalHeader, and the Section Table；the entries in the Data Directory

* 如何提取一个软件对PE格式解析时使用的约束？
  * 手动逆向！好家伙

首先，找到加载过程的内核和用户空间阶段的入口点，在ntoskrnl.exe中确定MiCreateImageFileMap函数，在ntdll.dll中确定LdrpInitializeProcess函数。

接着，使用IDA对两个函数及其子函数进行反编译（汇编代码->伪代码），这些函数的返回值大多是成功或失败值。

手工分析：找出所有exit的条件，追踪它们与输入文件的关系，并使用本文的模型语言构建模型。

#### 模型语言

自定义的语言：原因是现有的工具不适合本文场景，例如SMT-LIB缺少对模型循环的支持，而Dijkstra的GCL不支持结构化类型。

本文的语言设计目的是用于对PE格式的**合规检查**的模型化。

##### 输入的定义

只引入了**一个符号输入**来代表整个PE可执行文件。

通过这样做，我们可以将PE格式的不同组件视为相互连接和相互依赖的实体，从而允许我们的模型捕获涉及不同报头字段的复杂约束。

##### 符号的定义

允许我们引入额外的符号(例如，标签)，并将它们与对输入或其他符号的操作结果相关联。

我们语言的当前版本支持**算术和按位**操作，以及更复杂的操作，这些操作通常用于处理PE格式，例如ALIGNUP和ALIGNDOWN，分别将整数向上或向下取2的某个幂。

##### 谓词的定义

允许我们指定现有符号表达式之间的**布尔比较**，该比较的结果为真或假。

在这些语句中，可以使用比较操作符和逻辑操作符，以及更复杂的操作符，例如ISPOW2来检查操作数是否为2的幂。

##### 终结符谓词

我们语言中的谓词既可以是终结符也可以是非终结符。要认为输入文件符合模型，必须满足终端谓词。相反，非终结符谓词没有这样的要求，因此在处理条件谓词时很有帮助，这一点我们将在后面讨论。

##### 条件谓词

这些允许编码谓词的形式为P: A==>B，其中A是一个非终结谓词。换句话说，如果谓词A为真，那么布尔谓词B也必须为真，才能满足整个谓词P。

转化为SMT： ¬A∨B 非A或B。

##### 结构化类型

通过允许在原始文件上强制转换结构化类型，并允许对每个头字段使用助记符名称，从而使模型更具可读性。类型可以定义为类c结构。

##### 循环

在解析PE文件时经常使用循环，例如，强制列表或数组中的所有条目满足相同的约束。同样，上面讨论的所有语句都在循环中得到支持。

### 使用模型

#### 有效判断模块

根据模型判断一个输入文件是否有效。

具体来说，使用输入文件的数据作为模型的每个条件语句的输入，得到一组True or False；

若所有终结符谓词的输出均为True，那么认为输入文件有效；反之若出现False，则认为输入文件无效；

若

##### 应用场景

作为动态恶意软件分析管道的一部分，所有提供恶意软件检测和分析产品的主要安全公司都使用这种管道。特别是，它可以作为一个可靠的**预过滤**阶段，选择适当的沙箱(基于可以运行示例的OS)或**快速丢弃**无论如何都不能成功运行的畸形二进制文件。

![image-20211203161047602](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211203161047602.png)

#### 生成模块

1. 将模型转换为SMT问题；
2. 如何生成可执行的用户代码？
   * 添加了一个组件来指定生成的PE文件应该执行哪些代码，并将其“插入”到生成的文件中。
3. 使用Z3约束器求解，生成的结果可以进行以下四个方面工作。

##### 生成测试集

   * 如何生成一个文件对model a有效而对model b无效： P1 ∧ ¬P2 ;
   *  Bonus: the analysis framework tells the broken constraints in P2 ???

##### 样本差异分析

##### 生成模型的差异

   * Euristic iterative approach；
   * 对于每一次迭代，解决一个SMT问题对于 P1 ∧ ¬P2;

##### 生成大量结构化不同的样本

   * 针对非终止状态进行迭代；
   * 对于n种非终止状态，可以进行2^n次迭代；

<img src="http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211203161354232.png" alt="image-20211203161354232" style="zoom: 80%;" />

## 3. 结果和发现

### 研究对象

* 操作系统-Windows Program Loader (XP, 7, 10 1909) ：Both Kernel-space and User-space 
* 杀软-ClamAV: PE format-specific signature engine
* 逆向工具-Radare2: PE memory mapping
* Yara ：PE module

### 发现

#### Windows之间的比较

* Win7 doesn’t accept executables with ImageBase = 0
* Win7 and 10 check SizeOfHeaders under specific conditions, XP does not
* Win7 and XP accept relocation types that 10 does not 
* Win7 and 10 discard binaries with entry point within the header
* Win7 does not load binaries whose SizeOfImage is smaller than the offset of the last byte of the section table

#### Windows vs. ClamAV

* Number of sections (ClamAV: max 96, Windows: max 65k) 
* SizeOfOptionalHeader (ClamAV: ≥ 92, Windows: no constraints) 
* Section Virtual Address (ClamAV: must always be aligned, Windows: under certain conditions not necessarily aligned)

#### 内存映射差异

* The Source of All Evil: handling SectionAlignment < Page Size (4KB in Intel) 
  * Windows: 按照文件本身映射到内存，而不管节区表；
  * Radare2, yara, ClamAV: 根据节区表映射文件到内存；
* 关于此行为，没有文档说明；

#### 值得注意的结果

* Windows加载程序后的内存与radare认为的内存是不一样的；

![image-20211203165312373](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211203165312373.png)

### 野外的发现

在2543个样本中，根据我们的Windows XP、Windows 7和Windows  10模型，我们的模型预测出632个、261个和86个是无效的。

为了验证预测的准确性，我们在运行各自版本Windows操作系统的VM中执行每个示例:所有示例都未能运行，正如我们的模型所预测的那样。

我们相信，这是有力的证据，表明我们的模型没有受到过度约束。我们还调查了无效PE样品率高的原因：

​	最常见的问题是，这些PE文件针对的是使用SubsystemVersion字段的最新Windows版本。其他示例是无效的，因为它们针对的是Intel x86以外的其他架构，或者因为它们是内核模块，不能作为独立的可执行文件运行。

## 4. 结论

* 不同的windows版本对PE文件有不同的解析方法；
* 安全工具应该构建多种Windows加载器的模型；
* 开源：https://github.com/eurecom-s3/loaders_modeling

## 总结

* 以人工逆向的方式构建PE文件格式的模型，将模型转换为SMT问题，使用z3约束器求解得到PE文件是否有效或产生一个解。

## 参考资料

1. yara规则：www.ucloud.cn/yun/11132.html
2. slides: https://i.blackhat.com/EU-21/Wednesday/EU-21-Nisi-Lost-In-The-Loader.pdf