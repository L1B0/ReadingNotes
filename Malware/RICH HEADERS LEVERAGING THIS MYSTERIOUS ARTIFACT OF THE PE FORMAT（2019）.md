# RICH HEADERS: LEVERAGING THIS MYSTERIOUS ARTIFACT OF THE PE FORMAT（2019）

## Rich Header是什么

- Rich Header存在被malwarer利用的价值
  - 结尾以四个字节`Rich`+四个字节XOR Key`C6 1B AC B7`；
  - 开头16个字节的数据用Key异或，得到`DanS`+12个字节的`00`

![image-20211208143411519](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211208143411519.png)

- 由下图看到，数据是一个简单的64位PRODITEM结构数组，它由两个32位字段组成:dwProdid和dwCount。dwProdid字段是产品标识符(ProdID)及其对应的Build号的组合，可以认为是两个独立的16位值。

![image-20211208143745004](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211208143745004.png)

- 寻找Rich Header最简单的方法：
  - 在DOS和PE Header之间寻找Rich字符串，获取后面的xor key；
  - 从Rich往前搜索，直到DWORD与key异或的结果是DanS；
  - DanS与Key之间即Rich Header;

![image-20211208144624870](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211208144624870.png)

### XOR Key

key是Microsoft编译器(链接器)为构建的每个可执行文件生成的唯一的4字节值。该值是DOS头、DOS存根和明文Rich Header数据的校验和。

校验和计算算法可以在Visual Studio的link.exe二进制文件中的IMAGE::CbBuildProdidBlock函数中找到。

代码片段如图所示:

![image-20211208144742089](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211208144742089.png)

可以看到算法的逻辑是加法和循环左移，存在不同的Rich Header产生相同的key的情况：

![image-20211208145153816](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211208145153816.png)

### 出现的频率

当查看由大约100万个独特的Win32和Win64本地二进制文件(没有。net)组成的**大型恶意数据集**时，我们发现**73.20%**的pe包含Rich Header。在26.80%不包含Rich Header的文件中，许多是由其他编译器(Turbo c++、MinGW  GCC、Clang等)生成的，或者是在完全不同的环境中开发的。

![image-20211208145335664](http://gavinl1b0223342.oss-cn-beijing.aliyuncs.com/img/image-20211208145335664.png)

### 价值

- 从packed file恢复原始代码：由于像Enigma Protector,  Themida和VMProtect这样的商业保护程序保留了原始文件的富头。这意味着当我们得到，比如说，一个受themida保护的文件时，我们可以通过搜索相同的Rich Headers来查找原始的、未打包的有效负载，反之亦然。这是特别有价值的